{namespace docsJSXComponents}

/**
 * This template will be rendered by SoyWeb when the user loads static.soy.
 * It deliberately includes dummy data so the designer can get a feel for how
 * the task list will appear with real data rather with minimal copy and paste.
 */
{template .soyweb}
{call docs.layout}
	{param content kind="html"}
		<h1>JSX 组件</h1>

		<p>
			先了解关于怎样使用 JSX 模板构建组件的实用教程，请确保学过了 <a href="/docs/modal.html">模态框教程</a>。
		</p>

		<p>
			本指南将说明 <strong>Metal.js</strong> 组件和 <a href="https://facebook.github.io/jsx/">jsx 模板</a> 之间集成的有关细节。
		</p>

		<p>
			注意，<strong>Metal.js</strong> 与模板无关，因此它根本不需要使用 JSX。也就是说，我们已经提供了 metal 组件和 JSX 之间很好的集成，因此如果您喜欢它的话可以试一试。
		</p>

		<h2>JSXComponent</h2>

		<p>
			要在您的 <strong>Metal.js</strong> 组件中使用JSX，您唯一要做的是从 <strong>JSXComponent</strong> 扩展，像这样：
		</p>

		<textarea class="code" data-mode="javascript">
{literal}import JSXComponent from 'metal-jsx';

class MyComponent extends JSXComponent {
}

export default MyComponent;{/literal}
		</textarea>

		<h2><code>render</code> 方法</h2>

		<p>
			现在我们已经从 <strong>JSXComponent</strong> 扩展了，我们能够在 <code>render</code> 方法中使用 jsx 来指定我们的组件应该渲染什么了。
		</p>

		<textarea class="code" data-mode="javascript">
{literal}import JSXComponent from 'metal-jsx';

class MyComponent extends JSXComponent {
	render() {
		return &lt;div class={this.config.cssClass}&gt;
			Hello {this.name}
		&lt;/div&gt;;
	}
}

MyComponent.STATE = {
	name: {
		validator: core.isString,
		value: 'World'
	}
};

export default MyComponent;{/literal}
		</textarea>

		<p>
			注意组件能够有两种类型的数据： <a href="/docs/state.html">state</a> 和 <a href="/docs/state.html#config">config</a>。
			主要的区别是：config 是通过 <code>this.config</code> 进行访问并且是从父组件或者构建函数中接收到的原始数据；
			State 能够直接通过 <code>this</code> 访问, 像之前例子中的 <code>this.name</code>，并且能够配置验证器、设置、初始值及其他特性。
			查看关于 <a href="/docs/state.html">state</a> 的指南了解更多。
		</p>

		<h2>子配置</h2>

		<p>
			只要内容是通过组件的 jsx 标签传递的，通过 <code>children</code> 配置数据就会接收到。这样组件就能决定内容将被渲染，或者到底应该去哪里。
		</p>

		<p>
			例如，想象一个简单的列表组件，可以接收它的条目作为它的内容，像这样：
		</p>

		<textarea class="code" data-mode="javascript">
{literal}&lt;List&gt;
  &lt;li&gt;Item 1&lt;/li&gt;
  &lt;li&gt;Item 2&lt;/li&gt;
  &lt;li&gt;Item 3&lt;/li&gt;
&lt;/List&gt;{/literal}
		</textarea>

		<p>
			这能够通过使用 <code>children</code> 配置来实现：
		</p>

		<textarea class="code" data-mode="javascript">
{literal}class List extends JSXComponent {
  render() {
    return &lt;ul&gt;{this.config.children}&lt;/ul&gt;
  }
}{/literal}
		</textarea>

		<p>
		  如果您检查 <code>this.config.children</code>，您将会注意到它是一个对象数组。
		  这样处理组件的内容时候就很给力了。例如，您可以选择渲染 children 的一部分，像这样：
		</p>

		<textarea class="code" data-mode="javascript">
{literal}// Renders only the second item.
return &lt;ul&gt;{this.config.children[1]}&lt;/ul&gt;{/literal}
		</textarea>

		<p>甚至改变在渲染之前就应该接受的数据：</p>

		<textarea class="code" data-mode="javascript">
{literal}// Forces all items to use the 'my-list-item-class' css class.
this.config.children.forEach(child => {
  child.class = 'my-list-item-class';
};
return &lt;ul&gt;{this.config.children}&lt;/ul&gt;{/literal}
		</textarea>

		<h2>功能性组件</h2>

		<p>
			有时您会创建非常简单的组件，除了渲染自己的内容没有其他的行文。在这种情况下，您可以放弃使用类，只需要创建仅用来渲染内容的功能性组件来替代。
		</p>

		<p>
			例如，让我们创建一个简单的 <strong>Button</strong> 组件当做一个功能：
		</p>

		<textarea class="code" data-mode="javascript">
{literal}/**
 * Functional components receive the configuration
 * object as the first param.
 */
var Button = ({ cssClass, label }) => {
  return &lt;button type="button" class={cssClass}&gt;{label}&lt;/button&gt;;
};{/literal}
		</textarea>

		<p>
			此外，您还可以使用组件类的方式从父组件中使用它，例如：
		</p>

		<textarea class="code" data-mode="javascript">
{literal}&lt;Button cssClass="btn btn-primary" label="OK" /&gt;{/literal}
		</textarea>

		<h2>渲染 JSX 组件</h2>

		<p>
			JSX组件既能通过 <a href="rendering-components.html">常规的方式</a> 渲染，也能通过 <code>JSXComponent.render</code> 函数，像这样：
		</p>

		<textarea class="code" data-mode="javascript">
{literal}class Button extends JSXComponent {
  render() {
    // Your render logic
  }
}
JSXComponent.render(Button, {label: 'OK'}, parent);{/literal}
		</textarea>

		<p>
			您也能传递一个功能性的组件给它：
		</p>

		<textarea class="code" data-mode="javascript">
{literal}var Button = config => {
  // Your render logic
};
JSXComponent.render(Button, {label: 'OK'}, parent);{/literal}
		</textarea>

		<p>
			或者直接通过 JSX 渲染：
		</p>

		<textarea class="code" data-mode="javascript">
{literal}JSXComponent.render(<Button label="OK" />, parent);{/literal}
		</textarea>

		<h2>JSX 编译</h2>

		<p>
		  为了使 <strong>Metal.js</strong> 和 <strong>JSX</strong> 之间的集成工作，需要通过一个叫做 <a href="http://npmjs.com/package/babel-plugin-incremental-dom">babel-plugin-incremental-dom</a> 的 babel 插件
			来编译 JSX 代码。直接使用它意味着你需要手动配置它，因此我们也提供了 <a href="http://npmjs.com/package/babel-preset-metal-jsx">babel preset</a> 供您使用。
		</p>
	{/param}
{/call}
{/template}
