{namespace docsModalUpdates}

/**
 * This template will be rendered by SoyWeb when the user loads static.soy.
 * It deliberately includes dummy data so the designer can get a feel for how
 * the task list will appear with real data rather with minimal copy and paste.
 */
{template .soyweb}
{call docs.layout}
	{param content kind="html"}
		<h1>教程：模态框 - 更新</h1>

		<p>
			在 <a href="/docs/modal_events.html">前一章</a> 中，
			我们学习了怎样添加内联监听器来使得 <strong>模态框</strong> 的关闭按钮工作。
		</p>

		<p>
			我们首先实现了关闭时销毁整个 <strong>模态框</strong> 实例的特性。最好的方式是仅仅让模态框隐藏，以便于之后再次展现。
		</p>

		<h2 id="state">状态</h2>

		<p>
			我们已经看到通过构建函数传递数据给组件是可行的。不过默认情况下对于组件来说，这种数据是只读的。
			也就是说,它可以从外面收到，但不能从里面修改。
		</p>

		<p>
			当您需要改变组件的数据，以及改变会导致其 html 内容更新，您应该指出它将是组件状态的一部分。
		</p>

		<p>
			这可以通过使用组件的 <code>STATE</code> 静态变量来实现，其中您还可以配置状态属性，比如指定初始值和验证器。
		</p>

		<p>
			让我们添加一个 <code>shown</code> 属性到 <strong>Modal</strong> 的状态中，在<strong>src/Modal.js</strong>：
		</p>

		<textarea class="code" data-mode="javascript">
{literal}Modal.STATE = {
	shown: {
		// The default value will be: `true`.
		value: true
	}
};{/literal}
		</textarea>

		<p>
			多关于配置状态的细节，请查看 <a href="/docs/state.html">状态指南</a>。
		</p>

		<h2>更新模板</h2>

		<p>
			现在我们需要更新我们的模板，仅当 <code>shown</code> 是 true 时才显示模态框。
		</p>

		{call codeTabs.main}
			{param tabs: ['Soy: src/Modal.soy', 'JSX: src/Modal.js'] /}
			{param content kind="html"}
				<textarea class="code" data-mode="x-soy">
{literal}/**
 * State properties are passed to the "render" template in the same way as
 * config properties.
 * @param shown
 */
&lbrace;template .render&rbrace;
	&lt;div class="modal {$shown ? 'show': ''}"&gt;
		...
	&lt;/div&gt;
&lbrace;/template&rbrace;{/literal}
				</textarea>
				<textarea class="code hidden" data-mode="javascript">
{literal}/**
 * State properties are accessed directly from `this`.
 */
render() &lbrace;
	var cssClass = 'modal';
	if (this.shown) {
		cssClass += 'show';
	}
	return &lt;div class={cssClass}&gt;
		...
	&lt;/div&gt;;
}{/literal}
				</textarea>
			{/param}
		{/call}

		<h2>更新 <code>close</code> 方法</h2>

		<p>
			现在我们可以改变 <code>close</code> 方法来更新状态属性。
		</p>

		<textarea class="code" data-mode="javascript">
			{literal}close() {
  this.shown = false;
}{/literal}
		</textarea>

		<p>
			自动 <code>Metal.js</code> 使用了 <a href="http://google.github.io/incremental-dom/">增量 dom</a>，
			重新渲染仅会引起最小的 dom 更新。在这个案例中， <code>shown</code> css 类将会从模态框元素中被移除。
		</p>

		<h2>运行 demo</h2>

		<p>
			通过 <code>npm run build</code> 编译代码，并且在浏览器中打开 demo。
			点击 <strong>x</strong> 按钮将会像之前一样关闭模态框，但是检查 dom 时您会注意到它仅仅是被隐藏了，而不是从 dom 中移除。
		</p>

		<h2>玩玩状态数据</h2>

		<p>
			状态数据让更新组件的内容变得非常容易。如果您想快速看看它的工作，您能在浏览器的 javascript 控制台 做一些实现。
		</p>

		<p>
			首先让我们 hold 住 <code>Modal</code> 实例，以便于我们能够访问到它：
		</p>

		<textarea class="code" data-mode="javascript">
{literal}window.modal = new metal.Modal({
	header: 'My Modal',
	body: 'Built using Metal.js'
});{/literal}
		</textarea>

		<p>
			现在重新运行 demo，在浏览器的控制台中键入：<code>modal.shown = false</code>。
			你会注意到模态框会和期望一样被隐藏。如果你再键入 <code>modal.shown = true</code>，它会再次展现出来。
		</p>

		<p>
			如果您还想同样地将 <code>header</code> 和 <code>body</code> 变成状态属性，您所要做的是：
		</p>

		<ol>
			<li>
				<p>
					将它们添加到 <code>STATE</code>，像这样：
				</p>

				<textarea class="code" data-mode="javascript">
		{literal}Modal.STATE = {
	body: {
		value: 'Default body'
	},
	header: {
		value: 'Default header'
	},
	shown: {
		value: true
	}
};{/literal}
				</textarea>
			</li>
			<li>
				<p>
					如果你正在使用JSX模板，将调用 <code>this.config</code> 变为直接从 <code>this</code> 中调用，像这样：
				</p>
				<textarea class="code" data-mode="javascript">
{literal}render() &lbrace;
	var cssClass = 'modal';
	if (this.shown) {
		cssClass += 'show';
	}
	return &lt;div class={cssClass}&gt;
		&lt;div class="modal-dialog"&gt;
			&lt;div class="modal-content"&gt;
				&lt;header class="modal-header"&gt;
					&lt;button onClick={this.close.bind(this)} type="button" class="close"&gt;
						&lt;span&gt;×&lt;/span&gt;
					&lt;/button&gt;
					&lt;h4&gt;{this.header}&lt;/h4&gt;
				&lt;/header&gt;
				&lt;section class="modal-body"&gt;
					{this.body}
				&lt;/section&gt;
				&lt;footer class="modal-footer"&gt;
					&lt;button type="button" class="btn btn-primary"&gt;OK&lt;/button&gt;
				&lt;/footer&gt;
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/div&gt;;
}{/literal}
				</textarea>
			</li>
		</ol>

		<p>
			现在，你如果在控制台中输入 <code>modal.header = 'New Header'</code> 之类的代码，内容也会自动更新。
		</p>

		<h2>接下来的步骤</h2>

		<p>
			我们的模态框正按预期工作。但是如果您想把它拆分成多个组件呢？我们如何一起使用它们？请在下一章中查看。
		</p>

		<p><strong><a href="/docs/modal_nested.html">↪ 教程：模态框 - 嵌套组件</a></strong></p>

	{/param}
{/call}
{/template}
