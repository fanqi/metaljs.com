{namespace docsInlineEvents}

/**
 * This template will be rendered by SoyWeb when the user loads static.soy.
 * It deliberately includes dummy data so the designer can get a feel for how
 * the task list will appear with real data rather with minimal copy and paste.
 */
{template .soyweb}
{call docs.layout}
	{param content kind="html"}
		<h1>内联事件</h1>

		<p>
			Metal.js 的另一个非常有用的特性是在模板中直接声明事件的能力。除了简单和直观，这个特性允许 Metal.js 处理附加事件本身，
			所以这可以以最好的方式完成，例如 <a href="https://learn.jquery.com/events/event-delegation/">代理</a>，
			而用户根本不用担心。当组件被处理释放时，这些事件也能被自动分离。
		</p>

		{call .functionName /}

		{call .functionReference /}

		<h2>内联监听器 - 嵌套组件</h2>

		<p>
			当使用 <a href="/docs/nested-components.html">嵌套组件</a> 时，也可以使用 <strong>events</strong> 属性内联事件：
    </p>

		{call codeTabs.main}
			{param tabs: ['Soy: src/Modal.soy', 'JSX: src/Modal.js'] /}
			{param content kind="html"}
				<textarea class="code" data-mode="x-soy">
{literal}&lbrace;call Button.render&rbrace;
  &lbrace;param events: ['click': ['selector': 'button', 'fn': 'close']] /&rbrace;
  &lbrace;param label: 'Ok' /&rbrace;
&lbrace;/call&rbrace;{/literal}
				</textarea>
				<textarea class="code hidden" data-mode="javascript">
{literal}var events = {click: {
  selector: 'button',
  fn: 'close'
}};
&lt;Button events={events} label="Ok" /&gt;{/literal}
				</textarea>
			{/param}
		{/call}

		<p>
			将导致每当与给定选择匹配的元素触发点击事件时，调用来自子组件的 <code>close</code> 函数。
		</p>

		<p>假如您想使用父组件中的方法监听事件，仅需要传递方法引用而不是字符串，像这样：</p>

		{call codeTabs.main}
			{param tabs: ['Soy: src/Modal.soy', 'JSX: src/Modal.js'] /}
			{param content kind="html"}
				<textarea class="code" data-mode="x-soy">
{literal}&lbrace;call Button.render&rbrace;
  &lbrace;param events: ['click': ['selector': 'button', 'fn': $close]] /&rbrace;
  &lbrace;param label: 'Ok' /&rbrace;
&lbrace;/call&rbrace;{/literal}
				</textarea>
				<textarea class="code hidden" data-mode="javascript">
{literal}var events = {click: {
  selector: 'button',
  fn: this.close.bind(this)
}};
&lt;Button events={events} label="Ok" /&gt;{/literal}
				</textarea>
			{/param}
		{/call}

		<p>
			除了 dom 事件，您也能用同样的方法监听来自子组件的自定义事件：
		</p>

		{call codeTabs.main}
			{param tabs: ['Soy: src/Modal.soy', 'JSX: src/Modal.js'] /}
			{param content kind="html"}
				<textarea class="code" data-mode="x-soy">
{literal}&lbrace;call Button.render&rbrace;
  &lbrace;param events: ['labelChanged': $handleLabelChanged] /&rbrace;
  &lbrace;param label: 'Ok' /&rbrace;
&lbrace;/call&rbrace;{/literal}
				</textarea>
				<textarea class="code hidden" data-mode="javascript">
{literal}var events = {labelChanged: this.handleLabelChanged.bind(this)};
&lt;Button events={events} label="Ok" /&gt;{/literal}
				</textarea>
			{/param}
		{/call}

		<h2>内联监听器 - 选择性的使用</h2>

		<p>
			除了 <code>on[EventName]</code> 格式您也可以用 <code>data-on[eventname]</code> 来添加内联监听器。例如：
		</p>

		<textarea class="code" data-mode="javascript">
			{literal}&lt;button data-onclick="close" type="button" class="close"&gt;{/literal}
		</textarea>

		<p>
			注意，这种格式主要是支持启用 <a href="/docs/progressive-enhancement.html">渐进增强</a>，
			例如当通过 Java 中运行 soy 模板时。当模板使用 <code>on[EventName]</code> 格式在Java中运行时，
			它们将输入带有真实属性的元素，在浏览器中可能会导致错误。
			相反在 JavaScript 中这些都能作为元素属性被使用，所以这些问题不会发生。
		</p>

		<p>
			所以自由地使用你最喜欢的格式，或者更适合您的需要的方式。
		</p>
	{/param}
{/call}
{/template}

/**
 */
{template .functionName}
	<h2>内联监听器 - 通过方法名称</h2>

	<p>您能很容易地通过模板添加 DOM 事件监听器，像这样：</p>

	<textarea class="code" data-mode="javascript">
		{literal}&lt;button onClick="close" type="button" class="close"&gt;{/literal}
	</textarea>

	<p>
		以上代码定义了一旦点击 <strong>x</strong>，将会调用组件的 <code>close</code> 方法。
	</p>
{/template}

/**
 */
{template .functionReference}
	<h2 id="function">内联监听器 - 通过方法引用</h2>

	<p>
		如果您喜欢，您也可以通过实际的函数引用（而不只是它的名字）内联监听器。
	</p>

	{call codeTabs.main}
		{param tabs: ['Soy: src/Modal.soy', 'JSX: src/Modal.js'] /}
		{param content kind="html"}
			<textarea class="code" data-mode="x-soy">
{literal}/**
 * In the "render" template, soy params that match a
 * component's function name will be that function
 * (automatically bound to the component instance).
 * @param close
 */
&lbrace;template .render&rbrace;
  // ...
  &lt;button onClick="{$close}" type="button" class="close"&gt;
  // ...
&lbrace;/template&rbrace;{/literal}
			</textarea>
			<textarea class="code hidden" data-mode="javascript">
	{literal}
&lt;button onClick={this.close.bind(this)} type="button" class="close"&gt;{/literal}
			</textarea>
		{/param}
	{/call}

	<p>
	  也可以像前面的示例一样以完全相同的方式工作。
	</p>
{/template}
